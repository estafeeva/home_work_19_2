# Приложение интернет магазина


## Задание 1

 Настройте виртуальное окружение.
 Создайте новый Django-проект.

## Задание 2
После успешного создания проекта сделайте первую настройку. Для этого:

 Создайте первое приложение с названием catalog.
 Внесите начальные настройки проекта.
 Сделайте настройку урлов (URL-файлов) для нового приложения.

## Задание 3
Подготовьте два шаблона для домашней страницы и страницы с контактной информацией.
Для создания шаблонов лучше использовать UIkit Bootstrap. Это удобный набор элементов, которые уже стилизованы и готовы к использованию. UIkit Bootstrap помогает избежать самостоятельной верстки макетов.
Если возникнут проблемы при создании собственного интерфейса, возьмите за основу данный шаблон: https://github.com/oscarbotru/.

## Задание 4
В приложении в контроллере реализуйте два контроллера:

 Контроллер, который отвечает за отображение домашней страницы.
 Контроллер, который отвечает за отображение контактной информации.

## * Дополнительное задание
Реализуйте обработку сбора обратной связи от пользователя, который зашел на страницу контактов и отправил свои данные для обратной связи.

Для POST-запроса обработка в контроллере будет выглядеть так:

def students_list(request):
    if request.method == 'POST':
        # в переменной request хранится информация о методе, который отправлял пользователь
        name = request.POST.get('name')
        # а также передается информация, которую заполнил пользователь
        print(name)
    return render(request, 'index.html')

# Продолжение развития магазина (подключние магазина к БД)

## Задание 1
Подключите СУБД PostgreSQL для работы в проекте, для этого:
Создайте базу данных в ручном режиме.
Внесите изменения в настройки подключения.

## Задание 2
В приложении каталога создайте модели:
Product,
Category.
Опишите для них начальные настройки.

К начальным настройкам модели относятся метод 
__str__
 и 
class Meta с описанием свойств модели.

##Задание 3
Для каждой модели опишите следующие поля:
Product
Наименование
Описание
Изображение (превью)
Категория
Цена за покупку
Дата создания (записи в БД)
Дата последнего изменения (записи в БД)
Category
Наименование
Описание
Свяжите продукт и категорию, используя связь между таблицами «Один ко многим».

У одной категории может быть много продуктов, но у одного продукта может быть только одна категория.
Воспользуйтесь специальным полем модели — ForeignKey().
При необходимости подробнее про то, как работает такое поле, можно почитать тут.
Поля «Дата создания» и «Дата последнего изменения» стали стандартом для моделей. Их общепринятые названия — created_at и updated_at соответственно.

Примечание
Для поля с изображением необходимо добавить соответствующие настройки (MEDIA URL, MEDIA ROOT, настроить URL для отображения медиаданных) в проект, а также установить библиотеку для работы с изображениями 
Pillow. Не забудьте обновить файл с зависимостями для проекта после установки новой библиотеки.

## Задание 4
Перенесите отображение моделей в базу данных с помощью инструмента миграций, для этого:
создайте миграции для новых моделей;
примените миграции;
внесите изменения в модель продукта, добавьте поле «Дата производства продукта» (manufactured_at), примените обновление структуры с помощью миграций;
откатите миграцию до состояния, когда поле «Дата производства продукта» (manufactured_at) для модели продукта еще не существовало, и удалите лишнюю миграцию.
Важно сохранять всю историю миграций проекта для сохранения целостности базы данных проекта.

### Подсказка
Чтобы сбросить миграцию до определенной (по номеру), можно воспользоваться командой python manage.py migrate имя_приложения номер_миграции (например, 0003)
Номер миграции написан в названии файла.

## Задание 5
Для моделей категории и продукта настройте отображение в административной панели. Для категорий выведите id и наименование в список отображения, а для продуктов выведите в список id, название, цену и категорию.
При этом интерфейс вывода продуктов настройте так, чтобы можно было результат отображения фильтровать по категории, а также осуществлять поиск по названию и полю описания.

## Задание 6
Через инструмент shell заполните список категорий, а также выберите список категорий, применив произвольные рассмотренные фильтры. В качестве решения приложите скриншот.
Установите библиотеку ipython для комфортной работы с инструментом shell. Не забудьте зафиксировать изменения в файле зависимостей проекта.

### Подсказка
1. В рамках задания реализуйте ORM-запросы на создание объектов, получение всех объектов, получение одного объекта по 
id, фильтрацию объектов по определенному полю и исключение объектов из выборки.
Для доступа к объектам используйте команду Model.objects… и дополняйте ее различными методами.
Документацию для методов взаимодействия с базой данных через Django ORM можно найти тут.
Чтобы создать объект, необходимо использовать метод create() и перечислить все обязательные поля
Чтобы получить список всех объектов, необходимо использовать метод all().
Чтобы получить один объект, используйте метод get().
Чтобы отфильтровать объекты по определенному значению поля, необходимо использовать метод filter() и указать в скобках 
имя_поля=”значение_поля”.
Чтобы исключить объекты из выборки по определенному значению поля, необходимо использовать метод 
exclude() и указать в скобках имя_поля=”значение_поля”.

2. Сформируйте фикстуры для заполнения базы данных.
Фикстуры создайте командой. Для управления кодировкой используйте опцию 
-Xutf8 для команды. Такой параметр уместно будет использовать на операционной системе Windows.
В общем случае команда для создания фикстур будет выглядеть следующим образом:
python -Xutf8 manage.py dumpdata имя_приложения > имя_папки_с_фикстурами/имя_приложения_data.json

3. Напишите кастомную команду, которая умеет заполнять данные в базу данных, при этом предварительно ее зачищать от старых данных.

# Продолжение наполнения магазина (данные из БД)

## Задание 1
Создайте новый контроллер и шаблон, которые будут отвечать за отображение отдельной страницы с товаром, на которой необходимо вывести всю информацию о самом товаре.

### Подсказка
Контроллер для отдельной страницы с товаром — это отображение одного товара.
Товар хранится в базе данных с определенным id (в Django принято использовать pk (PrimaryKey)).
Чтобы получить данные о товаре, необходимо забрать данные о нем из базы данных. Сделать это с помощью ORM-запроса, например: 
Model.objects.get(pk=pk)
Для выполнения такого ORM-запроса наш контроллер должен получать аргумент pk (или id) на вход. Контроллеры получают параметры из URL.
URL для контроллера отображения одного товара будет примерно таким: 
path('/путь_к_продукту/<int:pk>', имя_контроллера, name='имя_url')

Чтобы контроллер обработал переданный ему аргумент pk, нам нужно передать его в контроллер:
def имя_контроллера(request, pk):
Соберите контекст для шаблона. В контекст мы передаем данные, которые необходимо отобразить в шаблоне. Контекст формируется в виде словаря и передается в функцию render:
context = {'object': Model.objects.get(pk=pk)}
Обратите внимание на название ключа в словаре контекста. Через него мы будем получать данные об объекте в шаблоне.
Контекст необходимо передать в шаблон для обработки:
return render(request, 'путь_к_шаблону', context)
В самом шаблоне мы получаем данные через обращение к переданному в контексте объекту (по ключу) и обращаемся к его полям через точку, например: 
<p>{{ object.name }}</p>

## Задание 2
В созданный ранее шаблон для главной страницы выведите список товаров в цикле. Для единообразия выводимых карточек отображаемое описание необходимо обрезать после первых выведенных 100 символов.

### Подсказка
Все товары хранятся в базе данных.
Чтобы получить данные о товарах, необходимо забрать данные о них из базы данных. Сделать это с помощью ORM-запроса, например:
Model.objects.all()
Соберите контекст для шаблона. В контекст мы передаем данные, которые необходимо отобразить в шаблоне. Контекст формируется в виде словаря и передается в функцию render:
context = {'object_list': Model.objects.all()}
Обратите внимание на название ключа в словаре контекста. Через него мы будем получать данные об объекте в шаблоне.
Контекст необходимо передать в шаблон для обработки: return render(request, 'путь_к_шаблону', context)
В самом шаблоне нам нужно получать данные о каждом объекте из списка — в шаблоне необходимо запустить цикл
{% for object in object_list %}
Теперь мы циклично будем обходить каждый объект в списке и обращаться к его полям через точку, например:
{{ object.name }}
Не забудьте закрыть цикл
{% endfor %}

## Задание 3
Из-за расширения количества шаблонов появляется слишком много повторяющегося кода, поэтому выделите общий (базовый) шаблон, а также подшаблон с главным меню.
В подшаблон вынесите общие для всех кодовые части (HTML-код). Не забудьте разместить блок с контентом, куда будут вставляться шаблоны, которые используют подшаблон:
{% block content %}
{% endblock %}
И подключите их к другим шаблонам с помощью
{% extends 'путь к базовому шаблону' %}
Код расширенного шаблона разместите внутри блока с контентом.

### Примечание
При необходимости можно выделить больше общих шаблонов.

## Задание 4
Для выводимого изображения на странице реализуйте шаблонный фильтр или шаблонный тег, который преобразует переданный путь в полный путь для доступа к медиафайлу.

### Подсказка
Создайте файл, например: 
your_app/templatetags/имя_файла.py
Создайте переменную для работы с библиотекой шаблонов Django:
register = template.Library()
Внутри файла используйте декоратор 
register.simple_tag()
 для регистрации тега или 
register.filter()
 для фильтра.
Создайте функцию тега/фильтра, которая будет принимать данные и добавлять к ним 
media/
 перед переданной строкой:
def mymedia(data):
    if data:
        return f'/media/{data}'
    return '#'
В вашем шаблоне загрузите ваш тег/фильтр 
{% load имя_файла %}
Используйте его для вывода пути к медиафайлу
<img class="card-img-top" src="{{ object.поле_изображения| название фильтра }}" ... >
или
<img class="card-img-top" src="{{ название тега object.поле_изображения }}" ... >
